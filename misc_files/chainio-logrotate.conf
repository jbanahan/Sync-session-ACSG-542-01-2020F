# This is the logrotate configuration file for chainio.
# Typically, most *nix systems have a logrotate instance that runs from a system cron job.
# You can then tap into this system job by placing your logrotate configuration file into a logrotate.d directory
# where the system logrotate looks for additional files.  On ubuntu systems, this directory is /etc/logrotate.d.
# Therefore, drop this file into that directory as just 'chainio' and let the log rotation fun begin.

/home/ubuntu/chainio/*/log/delayed_job.log 
/home/ubuntu/chainio/*/log/production.log 
/home/ubuntu/chainio/*/log/scheduler.log 
/home/ubuntu/chainio/*/log/newrelic_agent.log {
  size 50M
  compress
  rotate 3
  missingok
  # This command truncates the existing log file after copying it to the rotated log.  Used because 
  # none of the ruby processes generating these logs have functionality for being notified when 
  # logs should be changed.  So we instead copy the log data to a new file and truncate the existing one.
  # NOTE: This can cause small amounts of log data loss, but it's better than the alternative of killing
  # the ruby processes just to rotate its logs
  copytruncate
}

/opt/nginx/logs/access.log
/opt/nginx/logs/error.log {
  compress
  rotate 5
  missingok
  # delaycompress so that the log rotated during the current run will then be compressed the next run.
  # Used in conjunction with the postrotate command to tell nginx to open new log files.
  delaycompress

  # Only use the postrotate command once after both access and error logs are rotated
  sharedscripts

  # Tell nginx that it's time to close its current log file and start a new one (USR1 signal is what does this)
  # This works because the Linux kernel allows you to continue writing to files after they've been moved
  # and the output is "piped" into the moved file.
  postrotate
    [ ! -f /opt/nginx/logs/nginx.pid ] || kill -USR1 `cat /opt/nginx/log/nginx.pid`
  endscript
}
