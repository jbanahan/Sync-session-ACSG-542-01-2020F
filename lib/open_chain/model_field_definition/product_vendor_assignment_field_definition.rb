module OpenChain; module ModelFieldDefinition; module ProductVendorAssignmentFieldDefinition
  def add_product_vendor_assignment_fields
    make_read_only = lambda {|field_def_array|
      field_def_array.each {|fa| fa.last[:read_only] = true}
      field_def_array
    }
    add_fields CoreModule::PRODUCT_VENDOR_ASSIGNMENT, [
      # these ID fields are different than the ones generated by the make_*_arrays methods, because these are read only and
      # ok if the users see them
      [1, :prodven_vend_dbid, :vendor_id, "Vendor DB ID", {data_type: :integer, read_only:true}],
      [2, :prodven_prod_dbid, :product_id, "Product DB ID", {data_type: :integer, read_only:true}]
    ]
    add_fields CoreModule::PRODUCT_VENDOR_ASSIGNMENT, make_read_only.call(make_product_arrays(100, "prodven", "product_vendor_assignments"))
    add_fields CoreModule::PRODUCT_VENDOR_ASSIGNMENT, make_read_only.call(make_vendor_arrays(200, "prodven", "product_vendor_assignments"))
    pca_index = 1000
    product_custom_fields_to_add = []
    CustomDefinition.where(module_type:'Product').each_with_index do |cd, i|
      # Virtual fields won't work as nested searches at the moment...not entirely sure how we can make them work, so I'm skipping them for now
      next if cd.virtual_field?

      product_custom_fields_to_add << [
        pca_index+i,
        "#{cd.model_field_uid}_product_vendor_assignment".to_sym,
        "#{cd.model_field_uid}_product_vendor_assignment".to_sym,
        "Product - #{cd.label.to_s}", {
          data_type: cd.data_type,
          read_only: true,
          qualified_field_name: "(SELECT custom_values.#{cd.data_column} FROM products INNER JOIN custom_values ON custom_values.custom_definition_id = #{cd.id} AND custom_values.customizable_type = 'Product' and custom_values.customizable_id = products.id WHERE products.id = product_vendor_assignments.product_id)",
          export_lambda: lambda {|pva| pva.product ? pva.product.get_custom_value(cd).value : nil}
        }
      ]
    end
    vca_index = 2000
    vendor_custom_fields_to_add = []
    CustomDefinition.where(module_type:'Company').each_with_index do |cd, i|
      # Virtual fields won't work as nested searches at the moment...not entirely sure how we can make them work, so I'm skipping them for now
      next if cd.virtual_field?

      vendor_custom_fields_to_add << [
        vca_index+i,
        "#{cd.model_field_uid}_product_vendor_assignment".to_sym,
        "#{cd.model_field_uid}_product_vendor_assignment".to_sym,
        "Vendor - #{cd.label.to_s}", {
          data_type: cd.data_type,
          read_only: true,
          qualified_field_name: "(SELECT pva_custom_values.#{cd.data_column} FROM companies AS pva_vendors INNER JOIN custom_values AS pva_custom_values ON pva_custom_values.custom_definition_id = #{cd.id} AND pva_custom_values.customizable_type = 'Company' and pva_custom_values.customizable_id = pva_vendors.id WHERE pva_vendors.id = product_vendor_assignments.vendor_id)",
          export_lambda: lambda {|pva| pva.vendor.try(:custom_value, cd)}
        }
      ]
    end

    add_fields CoreModule::PRODUCT_VENDOR_ASSIGNMENT, product_custom_fields_to_add
    add_fields CoreModule::PRODUCT_VENDOR_ASSIGNMENT, vendor_custom_fields_to_add
  end
end; end; end
