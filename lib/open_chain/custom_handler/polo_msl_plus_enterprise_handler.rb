require 'open_chain/custom_handler/ack_file_handler'
require 'open_chain/custom_handler/polo/polo_custom_definition_support'

module OpenChain
  module CustomHandler
    class PoloMslPlusEnterpriseHandler
      include OpenChain::CustomHandler::Polo::PoloCustomDefinitionSupport

      # :env=>:qa will put files in _test_to_msl instead of _to_msl
      def initialize opts={}
        o = HashWithIndifferentAccess.new(opts)
        @env = o[:env].to_sym if o[:env]
      end

      def self.run_schedulable opts
        g = self.new(opts)
        prods = g.products_to_send.where("sync_records.sent_at < ? or sync_records.sent_at is null",6.hours.ago).limit(1000)
        while prods.count > 0
          g.send_and_delete_sync_file g.generate_outbound_sync_file prods
          prods = g.products_to_send.where("sync_records.sent_at < ? OR sync_records.sent_at is null",6.hours.ago).limit(1000)
        end
      end

      # find the products that need to be sent to MSL+ (they have MSL+ Receive Dates and need sync)
      def products_to_send
        init_outbound_custom_definitions
        cd_msl_rec = @out_cdefs[:msl_receive_date]
        sc = SearchCriterion.new(:model_field_uid=>"*cf_#{cd_msl_rec.id}",:operator=>"notnull")
        sc.apply(Product.select("distinct products.*").need_sync("MSLE"))
      end

      # Generate the file with data that needs to be sent back to MSL+
      def generate_outbound_sync_file products
        file = Tempfile.new(['msl_outbound','.csv'])
        headers = ["Style", "Country", "MP1 Flag", "HTS 1", "HTS 2", "HTS 3", "Length", "Width", "Height"]
        (1..15).each do |x|
          headers << "Fabric Type - #{x}"
          headers << "Fabric - #{x}"
          headers << "Fabric % - #{x}"
        end

        file << headers.to_csv
        dont_send_countries = Country.where("iso_code IN (?)",['US','CA','IT']).collect{|c| c.id}
        init_outbound_custom_definitions
        products.each do |p|
          classifications = p.classifications.includes(:country).where("not classifications.country_id IN (?)",dont_send_countries)
          classifications.each do |cl|
            iso = cl.country.iso_code
            cl.tariff_records.each do |tr|
              file << outbound_file_content(p, cl, tr, iso).to_csv
            end
          end
          sr = p.sync_records.find_or_initialize_by_trading_partner("MSLE")
          sr.update_attributes(:sent_at=>Time.now)
        end
        file.flush
        file
      end

      # Send the file created by `generate_outbound_sync_file`
      def send_and_delete_sync_file local_file, send_time=Time.now #only override send_time for test case
        send_file local_file, "ChainIO_HTSExport_#{send_time.strftime('%Y%m%d%H%M%S')}.csv"
        File.delete local_file 
      end

      #process the inbound file
      def process file_content
        init_inbound_custom_definitions
        field_map = {
          @in_defs[:msl_us_season] => 1,
          @in_defs[:msl_board_number] => 2,
          @in_defs[:msl_item_desc] => 3,
          @in_defs[:msl_model_desc] => 4,
          @in_defs[:msl_gcc_desc] => 5,
          @in_defs[:msl_hts_desc] => 6,
          @in_defs[:msl_hts_desc_2] => 7,
          @in_defs[:msl_hts_desc_3] => 8,
          @in_defs[:ax_subclass] => 9,
          @in_defs[:msl_us_brand] => 10,
          @in_defs[:msl_us_sub_brand] => 11,
          @in_defs[:msl_us_class] => 12
        }
        current_style = nil
        ack_file = Tempfile.new(['msl_ack','.csv'])
        ack_file << ['Style','Time Processed','Status'].to_csv
        begin 
          CSV.parse(file_content,:headers=>true) do |row|
            begin
            current_style = row[0]
            p = Product.find_or_create_by_unique_identifier current_style
            field_map.each {|k,v| p.update_custom_value! k,row[v]} 
            p.update_custom_value! @in_defs[:msl_receive_date], Date.today
            ack_file << [current_style,DateTime.now.utc.strftime("%Y%m%d%H%M%S"),"OK"].to_csv
            rescue
              ack_file << [current_style,DateTime.now.utc.strftime("%Y%m%d%H%M%S"),$!.message].to_csv
            end
          end
        rescue
          t = nil
          begin
            t = Tempfile.new(['msl_bad_file','.csv'])
            t << file_content
            t.flush
          rescue
            $!.log_me
          end
          $!.log_me ["MSL+ File Processing Error"], (t ? [t] : [])
          #write error here and log it
          ack_file << "INVALID CSV FILE ERROR: #{$!.message}"
        ensure
          ack_file.flush
        end
        ack_file
      end

      #transmit the inbound file generated by process(file_content)
      def send_and_delete_ack_file ack_file, original_file_name
        parts = original_file_name.split(".")
        ext = parts.slice!(-1)
        fn = "#{parts.join(".")}-ack.#{ext}"
        send_file ack_file, fn
        File.delete ack_file 
      end

      def send_file local_file, destination_file_name
        FtpSender.send_file("connect.vfitrack.net",'polo','pZZ117',local_file,{:folder=>(@env==:qa ? '/_test_to_msl' : '/_to_msl'),:remote_file_name=>destination_file_name})
      end

      private 
        def cust_def label, data_type="string"
          CustomDefinition.find_or_create_by_label_and_module_type label, "Product", :data_type=>data_type
        end
        def hts_value hts, country_iso
          h = hts.nil? ? "" : hts
          country_iso=="TW" ? h : h.hts_format
        end
        def mp1_value tariff_record, country_iso
          return "" unless country_iso == 'TW'
          found = OfficialTariff.
            where("hts_code IN (?)",[tariff_record.hts_1,tariff_record.hts_2,tariff_record.hts_3].compact).
            where("country_id = (SELECT ID from countries where iso_code = \"TW\")").
            where("import_regulations like \"%MP1%\"").count
          found > 0 ? "true" : ""
        end

        def init_outbound_custom_definitions
          if @out_cdefs.nil?
            cdefs = [:length_cm, :width_cm, :height_cm, :msl_receive_date]
            (1..15).each do |x|
              cdefs << "fabric_type_#{x}".to_sym
              cdefs << "fabric_#{x}".to_sym
              cdefs << "fabric_percent_#{x}".to_sym
            end
            cdefs << :msl_fiber_failure
            @out_cdefs = self.class.prep_custom_definitions cdefs
          end
          @out_cdefs
        end

        def init_inbound_custom_definitions
          if @in_defs.nil?
            @in_defs = self.class.prep_custom_definitions [:msl_receive_date, :msl_us_class, :msl_us_brand, :msl_us_sub_brand, :msl_model_desc, 
                          :msl_hts_desc, :msl_hts_desc_2, :msl_hts_desc_3, :ax_subclass, :msl_item_desc, :msl_us_season, 
                          :msl_gcc_desc, :msl_board_number]
          end
          @in_defs
        end

        def outbound_file_content p, cl, tr, iso
          file = [p.unique_identifier, iso, mp1_value(tr,iso), hts_value(tr.hts_1,iso), hts_value(tr.hts_2,iso), hts_value(tr.hts_3,iso),
                  p.get_custom_value(@out_cdefs[:length_cm]).value, p.get_custom_value(@out_cdefs[:width_cm]).value, p.get_custom_value(@out_cdefs[:height_cm]).value]

          parse_failure = p.get_custom_value(@out_cdefs[:msl_fiber_failure]).value

          # Make sure the value is ACTUALLY boolean false, that's the only value that we will allow to indicate the
          # fiber fields should be included.
          if parse_failure === false
            (1..15).each do |x|
              file << p.get_custom_value(@out_cdefs["fabric_type_#{x}".to_sym]).value
              file << p.get_custom_value(@out_cdefs["fabric_#{x}".to_sym]).value
              file << p.get_custom_value(@out_cdefs["fabric_percent_#{x}".to_sym]).value
            end
          else
            45.times {file << nil}
          end
          
          file
        end
    end
  end
end
