@components = angular.module 'ChainComponents', []

#Boolean filter for writing text, works similar to a ternary operator like:
# <div>{{x==1 | ifTrue : "I'm True" : "I'm not true"}}
@components.filter 'ifTrue', () ->
  (input,tVal,fVal) ->
    if input then tVal else fVal

@components.directive 'chainTextileView', [() ->
  {
    restrict: 'AE'
    scope: {
      ngModel:'='
    }
    template:"<div class='textile-view'></div>"
    link: (scope,el,attrs) ->
      if scope.ngModel && scope.ngModel.length > 0
        $(el).html(textile.convert(scope.ngModel))
      else
        $(el).html('')
    }
]

@components.directive 'chainTextileEdit', [() ->
  {
    restrict: 'AE'
    scope: {
      ngModel:'='
      defaultView:'@'
    }
    template:"<div>
      <div ng-show='showPreview' class='text-prev'>
      </div>
      <div ng-hide='showPreview'>
        <textarea class='form-control' ng-model='ngModel'></textarea>
      </div>
      <div class='text-right'>
        <div ng-hide='showPreview'><a class='btn btn-xs btn-default' href='' ng-click='togglePreview()'>preview</a></div>
        <div ng-show='showPreview'><a class='btn btn-xs btn-default' href='' ng-click='togglePreview()'>close preview</a></div>
      </div>
    </div>"
    link: (scope,el,attrs) ->
      scope.showPreview = scope.defaultView == 'preview'
      scope.togglePreview = () ->
        scope.showPreview = !scope.showPreview
      scope.$watch 'ngModel', (newVal,oldVal) ->
        $(el).find('div.text-prev').html(textile.convert(newVal))
      @
  }
]

# creates a bootstrap panel like:
# <chain-panel panel-title='Errors' panel-message="obj.error_message" panel-type='panel-danger' />
#
# auto hides / shows if message is set
@components.directive 'chainPanel', [() ->
  {
    restrict: 'AE'
    scope: {
      panelTitle:'@'
      panelMessage:'='
      panelType:'@'
    }
    template:"<div ng-show='panelMessage && panelMessage.length>0'><div class='panel' ng-class='panelType'><div class='panel-heading'><h3 class='panel-title'>{{panelTitle}}</h3></div><div class='panel-body'><p>{{panelMessage}}</p></div></div></div>"
    link: (scope,el,attrs) ->
      @
  }
]
# based on: http://coding-issues.blogspot.in/2013/10/angularjs-blur-directive.html
# should be able to remove this when we upgrade to a newer angularjs version that supports this natively
@components.directive('ngBlur', ['$parse', ($parse) ->
  (scope, element, attr) ->
    fn = $parse(attr['ngBlur'])
    element.bind 'blur', (event) ->
      scope.$apply () ->
        fn(scope, {$event:event})
])

# Shows the message from the given binding in a modal every time it changes. 
# Closes the modal if the message is changed to blank, nil or undefined
# The title attribute becomes the modal header title
@components.directive 'chainModalMessage', ['$timeout',($timeout) ->
  {
    scope:{
      chainModalMessage:'='
      clearOnClose:'='
    }
    template:"<div class='modal fade'><div class='modal-dialog'><div class='modal-content'><div class='modal-header'><button type='button' class='close' data-dismiss='modal' aria-hidden='true'>&times;</button><h3>{{title}}</h3></div>
      <div class='modal-body'><p>{{chainModalMessage}}</p></div>
      <div class='modal-footer'><button class='btn' data-dismiss='modal' aria-hidden='true'>Close</button></div>
      </div></div></div>"
    link: (scope,el,attrs) ->
      scope.title = attrs.title

      if scope.clearOnClose
        el.find('.modal').on 'hide', () ->
          $timeout () -> #prevents $digest already in progress error while also making sure $apply is called
            scope.chainModalMessage = ''

      scope.$watch 'chainModalMessage', (newVal,oldVal) ->
        if newVal && newVal.length > 0
          el.find('.modal').modal('show')
        else
          el.find('.modal').modal('hide')
      @
  }
]
# Full action bar replacement that loads up the action bar with the transcluded content.
# Use in conjunction with the @no_action_bar = true option in the rails controller which will hide the normal action bar in the layout
@components.directive 'chainActionBar', [() ->
  {
    transclude:true
    template:"<div class='navbar navbar-default navbar-fixed-bottom'><ul class='nav navbar-nav'><li><span ng-transclude></span></li></ul></div>"
    replace: true
    link: (scope,el,attrs) ->
      scope.$evalAsync () ->
        el.find('button').addClass('navbar-btn')
      @
  }
]


# file upload form based on: http://hayageek.com/ajax-file-upload-jquery/
# requires: jquery.form.js
@components.directive 'chainAttach', [() ->
  {
    restrict: 'A'
    scope:{
      chainAttach:'='
      attachableId:'@'
      attachableType:'@'
    }
    template:"<form class='form-inline' role='form' action='/attachments' method='post' enctype='multipart/form-data'>
      <div class='row'><div class='col-xs-4'>
        <input type='hidden' name='attachment[attachable_type]' value='{{attachableType}}' />
        <input type='hidden' name='attachment[attachable_id]' value='{{attachableId}}' />
        <input type='file' size='60' name='attachment[attached]' class='form-control' /> 
      </div><div class='col-xs-2'>
        <input type='submit' value='Upload' class='btn btn-sm btn-success' style='display:none;'>
      </div>
    </form>
    <div class='progress progress-striped active'>
      <div class='progress-bar' role='progress-bar'>
        <span class='sr-only'>Uploading</span>
      </div>
    </div>
    <div class='att-msg'></div>
      "
    link: (scope,el,attrs) ->
      el.find('div.progress').hide()
      fileEl = el.find('form input[type="file"]')
      fileEl.on('change', () ->
        if $(@).val()
          el.find('form input[type="submit"]').show()
        else
          el.find('form input[type="submit"]').hide()
      )
      options = {
        dataType: 'json'
        beforeSend: () ->
          if el.find('form input[type="file"]').val()
            el.find('form').hide()
            el.children('div.progress').show()
            #clear everything
            el.find('div.progress').show()
            el.find('div.progress div.progress-bar').width('0%')
            el.find('div.att-msg').html('Upload starting')
          else
            el.find('div.att-msg').html('You must select a file to upload.')
        uploadProgress: (event, position, total, percentComplete) ->
          el.find('div.progress div.progressbar').width(percentComplete+"%")
          if percentComplete == 100
            el.find('div.att-msg').html("processing upload")
          else
            el.find('div.att-msg').html(percentComplete+'% uploaded')
        success: (data) ->
          el.find('div.att-msg').html('')
          el.find('form input[type="file"]').val('')
          el.find('form').show()
          scope.chainAttach.attachments = data.attachments
          scope.$apply()
        complete: (response) ->
          el.find('div.progress').hide()
        error: () ->
          el.find('div.att-msg').addClass('error').html('There was an error uploading this file. Please reload the page.')
      }
      el.find('form').ajaxForm(options)
  }
]

@components.directive 'chainActionButton', ['$parse',($parse) ->
  {
    restrict:'A'
    link: (scope,el,attrs) ->
      bId = el.attr('id')
      newButton = $('#nav-action-bar #chain-action-button-'+bId)
      if newButton.length == 0
        el.hide()
        actionBar = $('#nav-action-bar')
        actionBar.append("<button class='btn btn-default' id='chain-action-button-"+bId+"'>"+el.html()+"</button>")
        newButton = actionBar.find('#chain-action-button-'+bId)
        newButton.on('click',() ->
          $('#'+bId).click()
        )

      if attrs.chainShow
        scope.$watch $parse(attrs.chainShow)(scope), (newVal,oldVal)->
          if newVal
            newButton.show()
          else
            newButton.hide()
      
  }
]
# moves the transcluded content into the action bar
# each instance must have a unique ID attribute
@components.directive 'chainActionBarItem', [() ->
  {
    transclude:true
    template:"<div class='chainActionBarWrap' style='display:inline;' ng-transclude></div>"
    link: (scope,el,attrs) ->
      d = el.find('div.chainActionBarWrap')
      d.attr('action-bar-item-id',el.attr('id'))
      existingEl = $('#nav-action-bar div.chainActionBarWrap[action-bar-item-id="'+el.attr('id')+'"]')
      existingEl.remove()
      $("#nav-action-bar").append(d)
      d.find('button').button()
    }
]

# creates a modal dialog box with a link based on the title attributes and transcludes the content into the body of the dialog.  There will be an "OK" button to close the dialog.
@components.directive 'chainMessageBox', [() ->
  {
    scope: {
      title:'=title'
      asButton:'=asButton'
      extraClass:'=extraClass'
    }
    transclude:true
    template:"<div class='dialog_content_wrap' ng-transclude></div>"
    link: (scope,el,attrs) ->
      if scope.asButton
        el.prepend("<button class='btn chainMessageBoxLauncher "+scope.extraClass+"'>"+scope.title+"</button>")
      else
        el.prepend("<a class='btn chainMessageBoxLauncher "+scope.extraClass+"'>"+scope.title+'</a>')
      d = el.find("div.dialog_content_wrap")
      d.dialog({
        modal:true
        autoOpen:false
        buttons:{
          "OK": () ->
            $(@).dialog('close')
          }
        }
      )
      el.find(".chainMessageBoxLauncher").click(() ->
        d.dialog('open')
      )

      scope.$on('$destroy', () ->
        el.find(".chainMessageBoxLauncher").off('click')
        d.dialog('destroy')
        d.html("")
        el = null
        d = null
      )
    }
]


@components.service 'userListCache', ['$http',($http) ->
  
  {
    users: []
    waiting: false
    getListForCurrentUser: (callback) ->
      if @.users.length == 0
        svc = @
        $http.get('/users.json').success((data) ->
          svc.users = []
          for c in data
            cName = c.company.name
            for u in c.company.users
              u.company_name = cName
              svc.users.push u
          callback(svc.users)
        )
      else
        callback(@.users)
      
  }
]
# shows the user a drop down to select a user and sets the 
# selected user id into the passed in object
# <div user-list="myUserIdVariable"></div>
# optionally adding form-control="true" to the div will make the select object have the boostrap friendly form-control class
@components.directive 'chainUserList', ['$parse','$http','userListCache',($parse,$http,userListCache) ->
  {
    scope: {
      chainUserList:"="
    }
    template:"<select ng-model='chainUserList' ng-options='u.id as u.full_name group by u.company_name for u in users'></select>"
    link: (scope,el,attrs) ->
      if $(el).attr('form-control') == 'true'
        $(el).find('select').addClass('form-control')
      userListCache.getListForCurrentUser (users) ->
        scope.users = users
    }
]
@components.directive 'chainMessages', [() ->
  {
    scope: {
      errors:"=",
      notices:"="
    }
    templateUrl:'<%=asset_path("chain_messages.html")%>'
    }
]
@components.directive 'chainDatePicker', [() ->
  {
    scope: {
      chainDatePicker:"="
    }
    template:"<input type='text' disabled='disabled' />",
    link: (scope,el,attrs) ->
      el.find('input').datepicker({
        buttonText:'Select Date',
        dateFormat:'yy-mm-dd',
        onSelect:(text,dp) ->
          scope.$apply () ->
            scope.chainDatePicker = text
        showOn: 'button'
        }
      ).next(".ui-datepicker-trigger").addClass("btn btn-default")
      #add watch to update
      deregister = scope.$watch 'chainDatePicker', (newVal) ->
        el.find('input').val(newVal)

      # Remove the watch so el can get cleaned up
      scope.$on('$destroy', () ->
        deregister()
        input = el.find('input')
        if input.datepicker('widget')
          # Clear the onSelect for this datepicker so the scope is no longer referenced by the onSelect closure
          # Typically, we'd want to destroy the datepicker, but for some reason the destroy is blowing up because
          # the internal instance found in the destroy method is undefined (not sure if it's a jquery bug or usage bug)
          input.datepicker("option", "onSelect", () ->

          )
      )
  }
]
@components.directive 'chainSearchCriterion', ['$compile','chainSearchOperators',($compile,chainSearchOperators) ->
  {
    scope: {
      crit:"=chainSearchCriterion"
      modelFields: "=modelFields"
    }
    templateUrl:'<%=asset_path("chain_search_criterion.html")%>'
    controller: ['$scope',($scope) ->
      $scope.operators = chainSearchOperators.ops

      $scope.getMatchingModelFieldTypes = (datatypes, excludeMfId) ->
        match = []
        for field in @.modelFields
          if excludeMfId != field.mfid
            for type in datatypes
              if field.datatype == type
                match.push(field)
                break
        match

      $scope.findByMfid = (ary,mfid) ->
        for m in ary
          return m if m.mfid==mfid
        null

      # parent controller needs to $watch for deleteMe and do the actual work of removing the object!
      $scope.remove = (crit) ->
        crit.deleteMe = true

      $scope.renderTextInput = (data_type, opr) ->
        switch opr
          when "in", "notin"
            return "<textarea rows='8' ng-model='crit.value' class='form-control'/><div><small class='muted'>Enter one value per line.</small></div>"
          when "null", "notnull"
            return ""

        return "<" + (if (data_type == "text") then "textarea rows='2'" else "input type='text'") + " ng-model='crit.value' class='form-control' />"

      $scope.renderInput = (rScope, el) ->
        dateStepper = false #true means apply jStepper to a relative date field
        v_str = "<input type='text' ng-model='crit.value' class='form-control' />"
        switch rScope.crit.datatype
          when "string", "integer", "fixnum", "decimal"
            v_str = rScope.renderTextInput rScope.crit.datatype, rScope.crit.operator
          when "date", "datetime"
            if chainSearchOperators.isRelative rScope.crit.datatype, rScope.crit.operator
              v_str = "<input type='text' ng-model='crit.value' class='form-control' />"
              dateStepper = true
            else if rScope.modelFields && chainSearchOperators.isFieldRelative rScope.crit.datatype, rScope.crit.operator
              # Angular doesn't appear to have a way to select the first option from the select box as a default, so using a new scope
              # property and setting the crit.value ahead of time is the only way to not have a blank option value show in the select box
              rScope.matchingModelFields = rScope.getMatchingModelFieldTypes ['date', 'datetime'], rScope.crit.mfid
              if rScope.matchingModelFields.length > 0 && !rScope.findByMfid(rScope.matchingModelFields, rScope.crit.value)
                rScope.crit.value = rScope.matchingModelFields[0].mfid

              v_str = "<select ng-model='crit.value' ng-options='f.mfid as f.label for f in matchingModelFields' class='form-control'></select>"
            else
              v_str = "<div style='display:inline;' chain-date-picker='crit.value'></div>"
          when "boolean"
            v_str = ""
          when "text"
            v_str = rScope.renderTextInput rScope.crit.datatype, rScope.crit.operator

        v = $compile(v_str)(rScope)
        va = $(el).find(".value_area")
        va.html(v)

        switch rScope.crit.datatype
          when "integer", "fixnum"
            va.find('input').jStepper({allowDecimals:false})
          when "decimal"
            va.find('input').jStepper()
        va.find('input').jStepper() if dateStepper

    ],

    link: (scope, el, attrs) ->
      deregister = scope.$watch 'crit.operator', ((newVal,oldVal, cbScope) ->

        # Reset the criterion value for date types when moving between operators that have different value types (ie. date -> field or date -> # days,etc)
        if cbScope.crit.datatype=='date' || cbScope.crit.datatype=='datetime'
          if !chainSearchOperators.isCompatibleDateOperators cbScope.crit.datatype, newVal, oldVal
            cbScope.crit.value = ""
         
        cbScope.renderInput(cbScope, el)
      ), false

      scope.$on('$destroy', () ->
        deregister()
        deregister = null
      )

      scope.renderInput(scope, el)
      null
  }
]
@components.service 'chainSearchOperators', [() ->
  {
    findOperator : (datatype, name) ->
      opList = @.ops[datatype]
      op = null
      if opList
        for o in opList
          if o.operator == name
            op = o 
            break
      op

    isRelative : (datatype, operator) ->
      op = @.findOperator datatype, operator
      if op then op.relative else false

    isFieldRelative : (datatype, operator) ->
      op = @.findOperator datatype, operator
      if op then op.fieldRelative else false

    isCompatibleDateOperators : (datatype, newOperatorString, oldOperatorString) ->
      newOp = @.findOperator datatype, newOperatorString
      oldOp = @.findOperator datatype, oldOperatorString

      compatible = false
      if newOp? and oldOp?
        if newOp.relative
          compatible = oldOp.relative == true
        else if newOp.fieldRelative
          compatible = oldOp.fieldRelative == true
        else 
          compatible = (!oldOp.relative? && !oldOp.fieldRelative?)

      return compatible


    ops : {
      date: [
        {operator:'eq',label:'Equals'}
        {operator:'nq',label:'Not Equal To'}
        {operator:'gt',label:'After'}
        {operator:'lt',label:'Before'}
        {operator:'bda',label:'Before _ Days Ago',relative:true}
        {operator:'ada',label:'After _ Days Ago',relative:true}
        {operator:'bdf',label:'Before _ Days From Now',relative:true}
        {operator:'adf',label:'After _ Days From Now',relative:true}
        {operator:'pm',label:'Previous _ Months',relative:true}
        {operator:'null',label:'Is Empty'}
        {operator:'notnull',label:'Is Not Empty'}
        {operator:'afld',label:'After (Field)', fieldRelative: true}
        {operator:'bfld',label:'Before (Field)', fieldRelative: true}
        {operator:'regexp',label:'Regex'}
        ]
      datetime: [
        {operator:'eq',label:'Equals'}
        {operator:'nq',label:'Not Equal To'}
        {operator:'gt',label:'After'}
        {operator:'lt',label:'Before'}
        {operator:'bda',label:'Before _ Days Ago',relative:true}
        {operator:'ada',label:'After _ Days Ago',relative:true}
        {operator:'bdf',label:'Before _ Days From Now',relative:true}
        {operator:'adf',label:'After _ Days From Now',relative:true}
        {operator:'pm',label:'Previous _ Months',relative:true}
        {operator:'null',label:'Is Empty'}
        {operator:'notnull',label:'Is Not Empty'}
        {operator:'afld',label:'After (Field)', fieldRelative: true}
        {operator:'bfld',label:'Before (Field)', fieldRelative: true}
        {operator:'regexp',label:'Regex'}
        ]
      integer: [
        {operator:'eq',label:'Equals'}
        {operator:'nq',label:'Not Equal To'}
        {operator:'gt',label:'Greater Than'}
        {operator:'lt',label:'Less Than'}
        {operator:'sw',label:'Starts With'}
        {operator:'ew',label:'Ends With'}
        {operator:'nsw',label:"Does Not Start With"}
        {operator:'new',label:"Does Not End With"}
        {operator:'co',label:'Contains'}
        {operator:'in',label:'One Of'}
        {operator:'notin',label:'Not One Of'}
        {operator:'null',label:'Is Empty'}
        {operator:'notnull',label:'Is Not Empty'}
        {operator:'regexp',label:'Regex'}
        ]
      decimal: [
        {operator:'eq',label:'Equals'}
        {operator:'nq',label:'Not Equal To'}
        {operator:'gt',label:'Greater Than'}
        {operator:'lt',label:'Less Than'}
        {operator:'sw',label:'Starts With'}
        {operator:'ew',label:'Ends With'}
        {operator:'nsw',label:"Does Not Start With"}
        {operator:'new',label:"Does Not End With"}
        {operator:'co',label:'Contains'}
        {operator:'in',label:'One Of'}
        {operator:'notin',label:'Not One Of'}
        {operator:'null',label:'Is Empty'}
        {operator:'notnull',label:'Is Not Empty'}
        {operator:'regexp',label:'Regex'}
        ]
      fixnum: [
        {operator:'eq',label:'Equals'}
        {operator:'nq',label:'Not Equal To'}
        {operator:'gt',label:'Greater Than'}
        {operator:'lt',label:'Less Than'}
        {operator:'sw',label:'Starts With'}
        {operator:'ew',label:'Ends With'}
        {operator:'nsw',label:"Does Not Start With"}
        {operator:'new',label:"Does Not End With"}
        {operator:'co',label:'Contains'}
        {operator:'in',label:'One Of'}
        {operator:'notin',label:'Not One Of'}
        {operator:'null',label:'Is Empty'}
        {operator:'notnull',label:'Is Not Empty'}
        {operator:'regexp',label:'Regex'}
        ]
      string: [
        {operator:'eq',label:'Equals'}
        {operator:'nq',label:'Not Equal To'}
        {operator:'sw',label:'Starts With'}
        {operator:'ew',label:'Ends With'}
        {operator:'nsw',label:"Does Not Start With"}
        {operator:'new',label:"Does Not End With"}
        {operator:'co',label:'Contains'}
        {operator:'nc',label:"Doesn't Contain"}
        {operator:'in',label:'One Of'}
        {operator:'notin',label:'Not One Of'}
        {operator:'null',label:'Is Empty'}
        {operator:'notnull',label:'Is Not Empty'}
        {operator:'regexp',label:'Regex'}
        ]
      text: [
        {operator:'eq',label:'Equals'}
        {operator:'nq',label:'Not Equal To'}
        {operator:'sw',label:'Starts With'}
        {operator:'ew',label:'Ends With'}
        {operator:'nsw',label:"Does Not Start With"}
        {operator:'new',label:"Does Not End With"}
        {operator:'co',label:'Contains'}
        {operator:'nc',label:"Doesn't Contain"}
        {operator:'in',label:'One Of'}
        {operator:'notin',label:'Not One Of'}
        {operator:'null',label:'Is Empty'}
        {operator:'notnull',label:'Is Not Empty'}
        {operator:'regexp',label:'Regex'}
        ]
      boolean: [
        {operator:'notnull',label:'Yes'}
        {operator:'null',label:'No'}
        {operator:'regexp',label:'Regex'}
        ]
      }
    }
]
@components.directive 'chainSearchResult', ['$http',($http) ->
  {
    scope: {
      searchResult:"=chainSearchResult"
      page: "="
      errors:"="
      notices:"="
      urlPrefix:"@src"
      noChrome: "@"
      perPage: "="
    }
    transclude:true
    templateUrl:'<%=asset_path("search_result.html")%>'
    controller: ['$scope',($scope) ->

      $scope.loadedSearchId = null

      cookieIdentifier = (scope) ->
        scope.urlPrefix+scope.searchResult.id

      clearSelectionCookie = (scope) ->
        $.removeCookie(cookieIdentifier(scope))

      #write cookie for current selection state
      writeSelectionCookie = (scope) ->
        o = {rows:scope.bulkSelected,all:scope.allSelected}
        $.cookie(cookieIdentifier(scope),JSON.stringify(o))


      $scope.selectionCookieRead = false

      #load selection state values from cookie
      readSelectionCookie = (scope, searchId) ->
        usedIds = []
        v = $.cookie(cookieIdentifier(scope))
        if v
          o = $.parseJSON v
          scope.bulkSelected = o.rows
          scope.selectAll() if o.all
          for r in scope.searchResult.rows
            if $.inArray(r.id,scope.bulkSelected)>=0 && $.inArray(r.id,usedIds)==-1
              r.bulk_selected = true
              usedIds.push r.id
        $scope.selectionCookieRead = true

      loadResultPage = (scope, searchId, page) ->
        p = if page==undefined then 1 else page
        scope.searchResult = {id:searchId}
        url = scope.urlPrefix+searchId+'.json?page='+p #need to specify json here because of this rails bug https://github.com/rails/rails/issues/9940
        if scope.perPage
          url += "&per_page=" + scope.perPage

        $http.get(url).success((data,status,headers,config) ->
          # This is primarily just a backup check to make sure we're not attempting to load a page that doesn't exist, if
          # we do, just jump to the first page of the search results (note, this incurs another http request)
          if data.total_pages == 0 || data.total_pages >= page
            scope.searchResult = data
            scope.errors.push "Your search was too big.  Only the first " + scope.searchResult.total_pages + " pages are being shown."  if scope.errors && scope.searchResult.too_big

            scope.loadedsearchId = scope.searchResult.id
            readSelectionCookie scope, data.id
          else
            loadResultPage(scope, searchId, 1)
            
        ).error((data,status) ->
          if scope.errors
            if status == 404
              scope.errors.push "This search with id "+id+" could not be found."
            else
             scope.errors.push "An error occurred while loading this search result. Please reload and try again."
        )

      onSearchLoaded = (saved, scope) ->
        # We want to clear bulkSelections in this case since the user saved the setup (which will
        # re-run the search and likely invalidate existing bulk selections)
        if saved
          clearSelectionCookie scope
          scope.selectNone()
        
        if scope.searchResult.id != scope.loadedSearchId
          loadResultPage(scope, scope.searchResult.id, scope.page)

      #return array of valid page numbers for the current search result
      $scope.pageNumberArray = () ->
        if $scope.searchResult && $scope.searchResult.total_pages
          [1..$scope.searchResult.total_pages]
        else
          [1]

      #return true if the given row's id is different than the previous rows id
      $scope.newObjectRow = (idx) ->
        return true if idx==0
        myRowId = $scope.searchResult.rows[idx].id
        lastRowId = $scope.searchResult.rows[idx-1].id
        return myRowId!=lastRowId && idx>0

      #return the classes that should be applied to a result row based on it's position and whether it's the first instance of a new row key
      $scope.classesForRow = (idx) ->
        return [] if idx==0
        r = []
        r.push 'search_row_break' if $scope.newObjectRow(idx)
        r

      #
      # Bulk action handling
      #

      #active list of selected bulk actions
      $scope.bulkSelected = []
      $scope.allSelected = false
      $scope.selectPageCheck = false

      #clear selection
      $scope.selectNone = () ->
        $scope.bulkSelected = []
        $scope.allSelected = false
        r.bulk_selected = false for r in $scope.searchResult.rows if $scope.searchResult.rows

      $scope.selectAll = () ->
        $scope.allSelected = true
        r.bulk_selected = true for r in $scope.searchResult.rows

      $scope.selectPage = () ->
        r.bulk_selected = true for r in $scope.searchResult.rows

      #run a bulk action
      $scope.executeBulkAction = (bulkAction) ->
        selectedItems = $scope.bulkSelected
        sId = (if $scope.allSelected then $scope.searchResult.search_run_id else null)
        cb = null
        cb = eval(bulkAction.callback) if bulkAction.callback
        if cb
          BulkActions.submitBulkAction selectedItems, sId, bulkAction.path, 'post', cb
        else
          BulkActions.submitBulkAction selectedItems, sId, bulkAction.path, 'post'
      
      #pagination
      $scope.firstPage = () ->
        $scope.searchResult.page = 1
      
      $scope.lastPage = () ->
        $scope.searchResult.page = $scope.searchResult.total_pages

      $scope.nextPage = () ->
        $scope.searchResult.page++

      $scope.previousPage = () ->
        $scope.searchResult.page--

      registrations = []

      registrations.push($scope.$watch 'allSelected', (newValue,oldValue, cbScope) ->
        writeSelectionCookie(cbScope) unless newValue==oldValue
      )

      registrations.push($scope.$watch 'searchResult', ((newValue,oldValue, cbScope) ->
        if newValue && newValue.rows
          selectedIds = []
          nonSelectedIds = []
          for r in newValue.rows
          #split the selected and not selected items 
          #Because not every row has a checkbox, some items will be in both
          #we'll clean them up in the next step
            if r.bulk_selected
              selectedIds.push r.id
            else
              nonSelectedIds.push r.id

          # remove the selected ids from the non-selected list
          for sId in selectedIds
            idx = $.inArray(sId,nonSelectedIds)
            nonSelectedIds.splice(idx,1) if idx >= 0

          # remove the non-selected ids from the scope
          # we can't just clear it because we don't want to lose items from other pages that were loaded
          # by the cookie
          for nsId in nonSelectedIds
            idx = $.inArray(nsId,cbScope.bulkSelected)
            cbScope.bulkSelected.splice(idx,1) if idx >= 0
            cbScope.allSelected = false

          # put the selected items into the scope
          for sId in selectedIds
            cbScope.bulkSelected.push sId unless $.inArray(sId,cbScope.bulkSelected)>=0
            

        cbScope.selectPageCheck = false
        writeSelectionCookie cbScope if $scope.selectionCookieRead
        ), true #true means "deep search"
      )

      #
      # End bulk action handling
      #
      registrations.push($scope.$watch 'searchResult.id', (newVal, oldVal, cbScope) ->
        if newVal!=undefined && !isNaN(newVal) && newVal!=cbScope.loadedSearchId
          onSearchLoaded cbScope.searchResult.saved, cbScope
      )

      $scope.$on('$destroy', () ->
        deregister() for deregister in registrations
        registrations = null
      )
    ]
  }
]
